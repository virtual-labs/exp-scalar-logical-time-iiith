{
  "version": 2.0,
  "questions": [
    {
      "question": "In a scalar logical clock system, what is the initial clock value for all processes?",
      "answers": {
        "a": "1",
        "b": "0", 
        "c": "Current physical time",
        "d": "Process ID"
      },
      "explanations": {
        "a": "Incorrect. Processes typically start with 0 by convention.",
        "b": "Correct. Logical clocks conventionally start at 0.",
        "c": "Incorrect. Logical clocks are independent of physical time.",
        "d": "Incorrect. Process IDs are not used as initial clock values."
      },
      "correctAnswer": "b",
      "difficulty": "beginner"
    },
    {
      "question": "What is the purpose of the happens-before relation in distributed systems?",
      "answers": {
        "a": "To measure physical time differences",
        "b": "To establish causal ordering between events",
        "c": "To synchronize clocks across processes",
        "d": "To determine network latency"
      },
      "explanations": {
        "a": "Incorrect. The happens-before relation is about causality, not physical time.",
        "b": "Correct. The happens-before relation establishes causal ordering between events in a distributed system.",
        "c": "Incorrect. It's about event ordering, not clock synchronization.",
        "d": "Incorrect. Network latency measurement is not the purpose of this relation."
      },
      "correctAnswer": "b",
      "difficulty": "beginner"
    },
    {
      "question": "What does the 'd' represent in the scalar logical clock increment rule C_i ‚Üê C_i + d?",
      "answers": {
        "a": "The process ID",
        "b": "The increment amount (usually 1)",
        "c": "The number of messages sent",
        "d": "The physical time difference"
      },
      "explanations": {
        "a": "Incorrect. Process ID is separate from the increment value.",
        "b": "Correct. 'd' represents the increment amount, typically 1.",
        "c": "Incorrect. The increment is not based on message count.",
        "d": "Incorrect. Logical clocks don't use physical time differences."
      },
      "correctAnswer": "b",
      "difficulty": "beginner"
    },
    {
      "question": "What happens to logical clock values when a message is sent between processes?",
      "answers": {
        "a": "Only the sender's clock is incremented",
        "b": "Only the receiver's clock is incremented", 
        "c": "Both sender and receiver clocks are incremented according to specific rules",
        "d": "Neither clock changes"
      },
      "explanations": {
        "a": "Incorrect. The receiver must also update its clock upon message receipt.",
        "b": "Incorrect. The sender also increments its clock before sending.",
        "c": "Correct. Both processes update their clocks according to local and global rules.",
        "d": "Incorrect. Message passing requires clock updates for causal ordering."
      },
      "correctAnswer": "c",
      "difficulty": "intermediate"
    },
    {
      "question": "If process P1 has clock value 5 and receives a message with timestamp 8, what will P1's clock value be after processing the message (assuming increment d=1)?",
      "answers": {
        "a": "6",
        "b": "8",
        "c": "9",
        "d": "13"
      },
      "explanations": {
        "a": "Incorrect. The process must consider the message timestamp when updating its clock.",
        "b": "Incorrect. After taking the maximum, the clock must be incremented.",
        "c": "Correct. P1 sets its clock to max(5, 8) = 8, then increments by 1 to get 9.",
        "d": "Incorrect. The clocks are not added together."
      },
      "correctAnswer": "c",
      "difficulty": "intermediate"
    },
    {
      "question": "In practice, how is total ordering typically achieved with scalar logical clocks?",
      "answers": {
        "a": "By using the process with the highest clock value",
        "b": "By using tie-breaking mechanisms like process IDs when timestamps are equal",
        "c": "By synchronizing all clocks to the same value",
        "d": "By using vector clocks instead"
      },
      "explanations": {
        "a": "Incorrect. Total ordering requires consistent tie-breaking rules.",
        "b": "Correct. Process IDs or other deterministic criteria break ties between concurrent events.",
        "c": "Incorrect. Clock synchronization defeats the purpose of logical clocks.",
        "d": "Incorrect. Total ordering can be achieved with scalar clocks using tie-breakers."
      },
      "correctAnswer": "b",
      "difficulty": "intermediate"
    },
    {
      "question": "What is a fundamental limitation of scalar logical clocks compared to vector clocks?",
      "answers": {
        "a": "They cannot detect concurrency definitively",
        "b": "They use more memory",
        "c": "They are slower to compute",
        "d": "They require physical clock synchronization"
      },
      "explanations": {
        "a": "Correct. Scalar clocks cannot definitively identify concurrent events - they may have the same or different timestamps.",
        "b": "Incorrect. Scalar clocks use less memory than vector clocks.",
        "c": "Incorrect. Scalar clocks are faster to compute than vector clocks.",
        "d": "Incorrect. Logical clocks avoid physical clock synchronization."
      },
      "correctAnswer": "a",
      "difficulty": "advanced"
    },
    {
      "question": "In the context of distributed systems, what does monotonicity mean for scalar logical clocks?",
      "answers": {
        "a": "Clock values always increase and never decrease within a process",
        "b": "All processes have identical clock values",
        "c": "Clock values represent physical time accurately",
        "d": "Messages are delivered in timestamp order"
      },
      "explanations": {
        "a": "Correct. Monotonicity ensures that clock values within a process only increase, preserving causal order.",
        "b": "Incorrect. Processes maintain independent clocks with different values.",
        "c": "Incorrect. Logical clocks are independent of physical time.",
        "d": "Incorrect. Message delivery order is separate from timestamp monotonicity."
      },
      "correctAnswer": "a",
      "difficulty": "advanced"
    },
    {
      "question": "How do scalar logical clocks ensure that the happens-before relation is preserved in a distributed system with message losses?",
      "answers": {
        "a": "They retransmit lost messages automatically",
        "b": "They assume reliable message delivery for correctness",
        "c": "They use acknowledgments to confirm message receipt",
        "d": "They maintain backup timestamps"
      },
      "explanations": {
        "a": "Incorrect. Logical clocks don't handle message retransmission.",
        "b": "Correct. Scalar logical clocks assume the underlying communication is reliable for proper causality tracking.",
        "c": "Incorrect. Acknowledgments are not part of the basic scalar clock algorithm.",
        "d": "Incorrect. Backup timestamps are not used in scalar logical clocks."
      },
      "correctAnswer": "b",
      "difficulty": "advanced"
    }
  ]
}
